# Annotation -------------------------------------------------------------------

#' Read WFDB-compatible annotation file
#'
#' @description
#' The types of annotations that are supported are described below:
#'
#' * atr = manually reviewed and corrected reference annotation files
#' * ann = general annotator file
#' * ecgpuwave = `ecgpuwave` annotation types
#'
#' @inheritParams wfdb_io
#'
#' @details
#'
#' # Annotation files
#'
#' The following annotation file types are described below.
#'
#' ## ECGPUWAVE
#'
#' `ecgpuwave` analyses an ECG signal from the specified record, detecting the
#' QRS complexes and locating the beginning, peak, and end of the P, QRS, and
#' ST-T waveforms. The output of ecgpuwave is written as a standard WFDB-format
#' annotation file associated with the specified annotator. This file can be
#' converted into text format using rdann or viewed using wave.
#'
#' The QRS detector is based on the algorithm of Pan and Tompkins with some
#' improvements that make use of slope information. Optionally, QRS annotations
#' can be provided as input (see option -i), permitting the use of external QRS
#' detectors such as sqrs or manually-edited annotations (which can be created
#' using wave ). The waveform limit locator is based on the algorithm described
#' in reference 3 and evaluated in references 3 and 4.
#'
#' The output annotation file contains PWAVE ("p") and TWAVE ("t")
#' annotations that indicate the P- and T-wave peaks, as well as QRS annotations
#' (NORMAL ("N") if generated by the built-in QRS detector, or copies of the
#' input QRS annotations if these were supplied). ecgpuwave classifies each T
#' wave as type 0 (normal), 1 (inverted), 2 (positive monophasic), 3 (negative
#' monophasic), 4 (biphasic negative-positive), or 5 (biphasic
#' positive-negative); this numeric classification is written into the num field
#' of each TWAVE annotation. The P, QRS, and T waveform onsets and ends are
#' marked in the output annotation file using WFON ("(") and WFOFF (")")
#' annotations. The num field of each WFON and WFOFF annotation designates the
#' type of waveform with which it is associated: 0 for a P wave, 1 for a QRS
#' complex, or 2 for a T wave.
#'
#' @name wfdb_annotations
#' @export
read_annotation <- function(record,
														record_dir = ".",
														annotator,
														wfdb_path = getOption("wfdb_path"),
														begin = 0,
														end = NULL,
														...) {

	# Validate:
	#		WFDB software command
	# 	Current or parent working directory
	# 	Directory of the record/WFDB files
	# 	Variable definitions
	rdann <- find_wfdb_command('rdann')

	if (fs::dir_exists(record_dir)) {
		wd <- fs::path(record_dir)
	} else {
		wd <- getwd()
	}

	checkmate::assert_number(begin)

	# Create all the necessary parameters for rdann
	#		-f			Start time
	#		-t			End time
	#		-v			Column headings
	#		-e			Elapsed time as (versus absolute time)
	# TODO filtering flags not yet included
	cmd <-
		paste(rdann, '-r', record, '-a', annotator) |>
		{
			\(.) {
				if (begin != 0) {
					paste(., "-f", begin)
				} else {
					.
				}
			}
		}() |>
		{
			\(.) {
				if (!is.null(end)) {
					paste(., "-t", end)
				} else {
					.
				}
			}
		}() |>
		paste('-e')

	# Temporary local/working directory, to reset at end of function
	withr::with_dir(new = wd, code = {
		dat <-
			data.table::fread(cmd = cmd, header = FALSE)
	})

	# Rename and return as annotation table
	names(dat) <- c('time', 'sample', 'type', 'subtype', 'channel', 'number')
	new_annotation_table(df_list(dat), annotator)
}

#' @param data A table containing 6 columns
#' @return Outputs a WFDB with the provided extension
#' @rdname wfdb_annotations
#' @export
write_annotation <- function(data,
														 annotator,
														 record,
														 record_dir = ".",
														 wfdb_path = getOption("wfdb_path"),
														 ...) {


	# Validate:
	#		WFDB software command
	# 	Current or parent working directory
	# 	Variable definitions
	wrann <- find_wfdb_command('wrann')

	if (fs::dir_exists(record_dir)) {
		wd <- fs::path(record_dir)
	} else {
		wd <- getwd()
	}

	checkmate::assert_data_frame(data)

	# Take annotation data and write to temporary file
	# 	This later is sent to `wrann` through `cat` with a pipe
	#		The temp file must be deleted after
	tmpFile <- fs::file_temp("annotation_", ext = "txt")
	withr::defer(fs::file_delete(tmpFile))

	data |>
		annotation_table_to_lines() |>
		writeLines(tmpFile)

	# Prepare the command for writing this into a WFDB format
	#		Cat annotation file
	#		Pipe
	# 	Write out file
	cat_cmd <- paste('cat', tmpFile)
	wfdb_cmd <- paste(wrann, '-r', record, '-a', annotator)
	cmd <- paste(cat_cmd, wfdb_cmd, sep = " | ")
	withr::with_dir(new = wd, code = system(cmd))

}
