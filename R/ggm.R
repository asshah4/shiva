#' Visualization of EGMs using `ggplot`
#'
#' `r lifecycle::badge("experimental")`
#'
#' @param data Long-format data for visualization. It is a combined format that
#'   includes both signal data and header information. Can be generated by the
#'   [melt_egm()] function.
#'
#' @param channels Character vector of which channels to use. Can give either
#'   the channel label (e.g "CS 1-2") or the recording device/catheter type (e.g
#'   "His" or "ECG").
#'
#' @param time_frame A time range that should be displaced given in the format
#'   of a vector with a length of 2. The left value is the start, and right
#'   value is the end time. This is given in seconds (decimals may be used).
#'
#' @param annotation_channel Identifies which of the selected channels will be
#'   used for annotation. This channel will be used for the analysis of
#'   intervals, peaks, etc. If NULL, no annotations will be made.
#'
#' @param beats A integer vector that represents the indexed beats that should
#'   be analyzed within the plot. Each beat is indexed as `1...n` from what is
#'   within the __time_frame__ indicated. For example, if 5 beats are seen,
#'   `beats = c(1, 5)` would select the 1st and 5th beat. This can also refer to
#'   any large deflection that is consistent an EGM.
#'
#' @param intervals The choice of whether interval data will be included. An
#'   annotation channel must be present, otherwise nothing will be plotted. This
#'   argument allows several choices.
#'
#'   * __FALSE__: no intervals will be annotated, and is the default option
#'
#'   * __TRUE__: all intervals will be annotated
#'
#'   * __integer__: an integer vector that represents the indexed intervals that
#'   should be annotated. If NULL, no intervals will be annotated. For example,
#'   if their are 5 beats, than there are 4 intervals between them that can be
#'   labeled. They can be referenced by their index, e.g. `intervals = c(2)` to
#'   reference the 2nd interval in a 5 beat range.
#'
#' @import ggplot2 data.table
#' @export
ggm <- function(data,
								channels,
								time_frame = NULL,
								annotation_channel = NULL,
								beats = NULL,
								intervals = FALSE,
								hline = FALSE,
								vline = FALSE,
								...) {


	stopifnot(inherits(data, "data.frame"))

	# Check if time frame exists within series
	if (is.null(time_frame)) {
		time_frame <- c(min(data$time, na.rm = TRUE), max(data$time, na.rm = TRUE))
	}
	stopifnot("`time_frame` must be within available data" =
							all(time_frame %in% data$time))

	# Filter appropriately
	start_time <- time_frame[1]
	end_time <- time_frame[2]
	ch <- channels
	surface_leads <- c("I", "II", "III", paste0("V", 1:6), "AVF", "AVR", "AVR")
	ch_exact <- ch[which(ch %in% surface_leads | grepl("\ ", ch))]
	ch_fuzzy <- ch[which(!(ch %in% ch_exact))]
	ch_grep <-
		paste0(c(paste0("^", ch_exact, "$", collapse = "|"), ch_fuzzy),
					 collapse = "|")

	dt <-
		data[time >= start_time & time <= end_time
				][grepl(ch_grep, label)
					]

	# Frequency check
	hz <- unique(dt$freq)[1]

	# Final channels
	chs <- unique(dt$label)

	g <-
		ggplot(dt, aes(x = time, y = mV, color = color)) +
		geom_line() +
		facet_wrap( ~ label,
								ncol = 1,
								scales = "free_y",
								strip.position = "left") +
		scale_color_identity()

	### ANNOTATIONS ###


	if (!is.null(annotation_channel)) {
		stopifnot("The annotation channel must be one of the selected channels" =
								all(annotation_channel %in% chs))

		ann <- dt[label == annotation_channel]
		t <- ann$index
		peaks <-
			gsignal::findpeaks(ann$mV,
												 MinPeakHeight = max(ann$mV, na.rm = TRUE) / 2,
												 MinPeakDistance = 100,
												 DoubleSided = TRUE)
		pk_locs <- ann$time[peaks$loc]
		ints <- diff(peaks$loc)
		ints_locs <- pk_locs[1:length(ints)] + ints/(2 * hz)
		ht <- mean(peaks$pks, na.rm = TRUE)


		# Interval Annotations
		if (!isFALSE(intervals)) {
			stopifnot(inherits(as.integer(intervals), "integer"))
			stopifnot("Intervals are out of range based on channels selected" =
									all(intervals %in% seq_along(ints)))

			# Horizontal lines for intervals
			# Currently defunct
			if (hline) {
				gseg <- lapply(intervals, function(.x) {
					geom_segment(

										data = ann,
						aes(
							x = pk_locs[.x],
							xend = pk_locs[.x + 1],
							y = ht,
							yend = ht
						),
						linewidth = 0.1,
						inherit.aes = FALSE
					)
				})
				#g <- g + gseg
			}

			# Selected annotations for intervals
			if (isTRUE(intervals)) {
				# All intervals
				intervals <- seq_along(ints)
				gtxt <- lapply(intervals, function(.x) {
					geom_text(
						data = ann,
						aes(
							x = ints_locs[.x],
							y = ht / 2,
							label = ints[.x]
						),
						color = "black",
						inherit.aes = FALSE
					)
				})

				g <- g + gtxt
			} else if (inherits(as.integer(intervals), "integer")) {
				# Selected intervals
				gtxt <- lapply(intervals, function(.x) {
					geom_text(
						data = ann,
						aes(
							x = ints_locs[.x],
							y = ht / 2,
							label = ints[.x]
						),
						color = "black",
						inherit.aes = FALSE
					)
				})

				g <- g + gtxt

			}
		}

		# Vertical lines throughout
		if (vline) {
			g <- g + geom_vline(xintercept = pk_locs, alpha = 0.2)
		}

		# Beat Annotations
		if (!is.null(beats)) {
			stopifnot(inherits(as.integer(beats), "integer"))
			stopifnot("Not enough beats are present for the index beats selected" =
									all(beats <= length(peaks$pks)))
		}

	}

	# Theming
	g <- g +
		theme_egm() +
		scale_x_continuous(breaks = seq(time_frame[1], time_frame[2], by = 0.2),
											 label = NULL)

	# Return ggplot
	g

}



#' Custom theme for EGM data
#' @export
theme_egm <- function() {
	font <- "Arial"
	theme_minimal() %+replace%
		theme(

			# Panels
			panel.grid.major.y = element_blank(),
			panel.grid.minor.y = element_blank(),
			panel.grid.major.x = element_blank(),
			panel.grid.minor.x = element_blank(),

			# Axes
			axis.ticks.y = element_blank(),
			axis.title.y = element_blank(),
			axis.text.y = element_blank(),
			axis.title.x = element_blank(),
			axis.ticks.x = element_line(),

			# Facets
			panel.spacing = unit(0, units = "npc"),
			panel.background = element_blank(),
			strip.text.y.left = element_text(angle = 0, hjust = 1),

			# Legend
			legend.position = "none"
		)
}

#' Long Format of Header and Signal Data
#'
#' @param header A header table that contains key information about the overall
#'   signal in corresponding channels. Its assumed that the frequency of signal
#'   sampling is equivalent across channels.
#'
#' @param signal A `data.frame` (or similar) that contains the necessary signal.
#'   Each channel will be labeled using the header information (if unnamed).
#'
#' @param format The source of EGM information for specific formats. Support
#'   formats include...
#'
#'   * __lspro__: The LabSystem PRO from Boston Scientific _ascii.txt_ format
#'
#' @import data.table
#' @export
melt_egm <- function(header,
										 signal,
										 format,
										 ...) {

	stopifnot(inherits(header, "data.frame"))
	stopifnot(inherits(signal, "data.frame"))
	stopifnot(inherits(format, "character"))
	stopifnot(length(unique(header$freq)) == 1)

	switch(
		format,
		lspro = {
			# Ensure data.table format
			sig <- data.table(signal)
			hea <- data.table(header)

			# Should be all of the same frequency of data
			hz <- unique(header$freq)

			sig$index <- 1:nrow(sig)
			sig$time <- sig$index / hz
			dt <-
				melt(
					sig,
					id.vars = c("index", "time"),
					variable.name = "label",
					value.name = "mV"
				) |>
				{\(.x)
					hea[.x, on = .(label)]
				}()

			# Return
			dt
		}
	)



}
