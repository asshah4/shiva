#' Visualilzation of EGM using `ggplot`
#'
#' @param data Long-format data for visualization. It is a combined format that includes both signal data and header information. Can be generated by the [melt_egm()] function.
#'
#' @param frequency Integer value of the recording frequency (in Hertz).
#'
#' @param channels Character vector of which channels to use. Can give either
#'   the channel label (e.g "CS 1-2") or the recording device/catheter type (e.g
#'   "His" or "ECG").
#'
#' @param time_frame A time range that should be displaced given in the format
#'   of a vector with a length of 2. The left value is the start, and right
#'   value is the end time. This is given in seconds (decimals may be used).
#'
#' @import ggplot2 data.table
#' @export
gg_egm <- function(data,
									 frequency,
									 channels,
									 time_frame = NULL,
									 ...) {

	stopifnot(inherits(data, "data.frame"))

	# Check if time frame exists within series
	if (is.null(time_frame)) {
		time_frame <- c(min(data$time, na.rm = TRUE), max(data$time, na.rm = TRUE))
	}
	stopifnot("`time_frame` must be within available data" =
							all(time_frame %in% data$time))



	# Filter appropriately
	start_time <- time_frame[1]
	end_time <- time_frame[2]
	ch <- channels
	surface_leads <- c("I", "II", "III", paste0("V", 1:6), "AVF", "AVR", "AVR")
	ch_exact <- ch[which(ch %in% surface_leads | grepl("\ ", ch))]
	ch_fuzzy <- ch[which(!(ch %in% ch_exact))]
	chs <-
		paste0(c(paste0("^", ch_exact, "$", collapse = "|"), ch_fuzzy),
					 collapse = "|")

	dt <-
		data[time >= start_time & time <= end_time
				][grepl(chs, label)
					]

	ggplot(dt, aes(x = time, y = mV, color = source)) +
		geom_line() +
		facet_wrap( ~ label,
								ncol = 1,
								scales = "free_y",
								strip.position = "left") +
		theme_egm() +
		scale_x_continuous(breaks = seq(time_frame[1], time_frame[2], by = 0.2),
											 label = NULL)

}



#' Custom theme for EGM data
#' @export
theme_egm <- function() {
	font <- "Arial"
	theme_minimal() %+replace%
		theme(

			# Panels
			panel.grid.major.y = element_blank(),
			panel.grid.minor.y = element_blank(),
			panel.grid.major.x = element_blank(),
			panel.grid.minor.x = element_blank(),

			# Axes
			axis.ticks.y = element_blank(),
			axis.title.y = element_blank(),
			axis.text.y = element_blank(),
			axis.title.x = element_blank(),
			axis.ticks.x = element_line(),

			# Facets
			panel.spacing = unit(0, units = "npc"),
			panel.background = element_blank(),
			strip.text.y.left = element_text(angle = 0, hjust = 1),

			# Legend
			legend.position = "none"
		)
}

#' Long Format of Header and Signal Data
#'
#' @param header A header table that contains key information about the overall
#'   signal in corresponding channels. Its assumed that the frequency of signal
#'   sampling is equivalent across channels.
#'
#' @param signal A `data.frame` (or similar) that contains the necessary signal.
#'   Each channel will be labeled using the header information (if unnamed).
#'
#' @param format The source of EGM information for specific formats. Support
#'   formats include...
#'
#'   * __lspro__: The LabSystem PRO from Boston Scientific _ascii.txt_ format
#'
#' @import data.table
#' @export
melt_egm <- function(header,
										 signal,
										 format,
										 ...) {

	stopifnot(inherits(header, "data.frame"))
	stopifnot(inherits(signal, "data.frame"))
	stopifnot(inherits(format, "character"))
	stopifnot(length(unique(header$freq)) == 1)

	switch(
		format,
		lspro = {
			# Ensure data.table format
			sig <- data.table(signal)
			hea <- data.table(header)

			# Should be all of the same frequency of data
			hz <- unique(header$freq)

			sig$index <- 1:nrow(sig)
			sig$time <- sig$index / hz
			dt <-
				melt(
					sig,
					id.vars = c("index", "time"),
					variable.name = "label",
					value.name = "mV"
				) |>
				{\(.x)
					hea[.x, on = .(label)]
				}()

			# Return
			dt
		}
	)



}
